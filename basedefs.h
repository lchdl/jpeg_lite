#pragma once

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>
#include <new> /* for using replacement new */
#include "linalg.h"

typedef unsigned char BYTE;
typedef unsigned short WORD;
typedef unsigned int UINT;
typedef unsigned long DWORD;

/* define DEBUG_BREAK macro based on platform or compiler.      */
/* Current supported platforms: WINDOWS or LINUX-based systems. */
#if defined(_MSC_VER) /* if compile this program on MSVC/VS IDE */
#define DEBUG_BREAK __debugbreak(); /* then use builtin function */
#elif defined(__linux__)
#define DEBUG_BREAK raise(SIGTRAP); /* else we use raise(...) */
#else
#error "Cannot define DEBUG_BREAK macro due to unknown platform or compiler."
#endif

/* DEBUG_BREAK must be correctly defined before defining */
/* the following macro below.                            */
#if defined(_DEBUG) || defined(DEBUG) || defined(DEBUG_MODE)
#define debugCheck(condition, message)                          \
{                                                               \
	if ( (condition) == false ){                                \
		printf("%s\n", message);                                \
		DEBUG_BREAK;                                            \
	}                                                           \
}
#else
#define debugCheck(condition, message) 
#endif

/* * * * * * * * * * * * * * * * * * * * * * */
/* simple array exactly like C++ STL vector  */
/*   but I want to implement it myself :)    */
/* * * * * * * * * * * * * * * * * * * * * * */
template <typename T>
class Array {

    /*

    IMPORTANT NOTE:

    If "T" is a class rather than a pure data structure, then T must
    implement the following functions for correctly initializing/free
    memory spaces. I strongly recommend you to implement them manually
    and don't use the their default versions which are generated by the
    compilers.

    1) a DEFAULT constructor:         T::T().
    2) a (virtual) destructor:        (virtual) T::~T().
    3) a copy constructor:            T::T(const T&)().
    4) an overloaded operator "=":    T& operator=(const T&).

    */

public:

    Array() { baseptr = NULL; Ne = 0; Me = 0; }
    Array(const Array& that) {
        this->Ne = that.Ne;
        this->Me = that.Me;
        /* initialize baseptr */
        if (that.Me == 0) { /* copy an empty array */
            this->baseptr = NULL;
        }
        else {
            this->baseptr = (T*)malloc(sizeof(T) * this->Me);
            /* initialize used slots */
            for (int i = 0; i < this->Ne; i++) {
                new (&(this->baseptr[i])) T();
                /* may invoke overridden operator "=" if array element is */
                /* a class instance */
                this->baseptr[i] = that.baseptr[i];
            }
        }
    }
    virtual ~Array() { this->clear(); }
    

    Array& operator=(const Array& that) {
        if (this == &that) 
            return (*this); /* in case "a = a" will cause unexpected behavior */

        clear();

        this->Ne = that.Ne;
        this->Me = that.Me;
        /* initialize baseptr */
        if (that.Me == 0) { /* copy an empty array */
            this->baseptr = NULL;
        }
        else {
            this->baseptr = (T*)malloc(sizeof(T) * this->Me);
            /* initialize used slots */
            for (int i = 0; i < this->Ne; i++) {
                new (&(this->baseptr[i])) T();
                /* may invoke overridden operator "=" if array element is */
                /* a class instance */
                this->baseptr[i] = that.baseptr[i];
            }
        }
        
        return (*this);
    }
    
public:

    T& at(int index) {
        return baseptr[index];
    }
    T& operator[](int index) {
        return baseptr[index];
    }

    /* retrieve the last element (most recently added) */
    T& last() {
        return baseptr[size() - 1];
    }

    bool append(T& elem) {
        if (Ne == Me) expandStorage(); /* array is full, expand it */
        new (&(this->baseptr[Ne])) T(); /* init array last element and 
                                           prepare for assignment later */
        baseptr[Ne] = elem;
        Ne++;
        return true; /* normally append() will always success */
    }
    void clear() {
        /* if each element in the array is a class instance,     */
        /* we need to manually call destructor for each instance */
        /* in order to release memory propoerly (especially when */
        /* class instance member contains pointer(s)             */
        for (int i = 0; i < this->Ne; i++) {
            this->baseptr[i].~T();
        }
        /* then, free memory as usual */
        if (baseptr) free(baseptr);
        baseptr = NULL;
        Ne = Me = 0;
    }
    int size() { 
        return this->Ne; 
    }
    T* data() { return baseptr; }
    bool isEmpty() { return (this->Ne == 0); }

protected:
    T* baseptr; /* data pointer */
    int Ne, Me; /* number of elements and max number of elements allowed */

protected:
    void expandStorage() {
        if (Me == 0) { /* array is not initialized */
            Me = 16;
            baseptr = (T*)malloc(sizeof(T) * Me);
        }
        else {
            int maxIncreaseAllowed = 64 * 1024 * 1024; /* maximum 64MB per increase */
            int maxElementsIncrease = maxIncreaseAllowed / sizeof(T);
            int newMe = int(double(Me) * 1.1);
            if (maxElementsIncrease < 16) { 
                maxElementsIncrease = 16;
            }
            if (newMe - Me > maxElementsIncrease) {
                newMe = Me + maxElementsIncrease; /* limit increase amount */
            }
            baseptr = (T*)realloc(baseptr, sizeof(T) * newMe); /* expand size */
            Me = newMe;
        }
    }
};

/* Fixed size 2D Array */
template <typename T>
class FixedArray2D{
public:
    FixedArray2D() { baseptr = NULL; nX = nY = 0; }
    FixedArray2D(const FixedArray2D& that) {
        /* because the size of 2D array is fixed, we ignore the copy operation if the 
        size of these arrays are not equal. */
        if (that.baseptr == NULL || this->nX != that.nX || this->nY != that.nY) {
            return;
        }
        for (int i = 0; i < this->nX * this->nY; i++) {
            /* may invoke overridden operator "=" for a class instance */
            this->baseptr[i] = that.baseptr[i];
        }
    }
    virtual ~FixedArray2D() { this->clear(); }

    FixedArray2D& operator=(const FixedArray2D& that) {
        if (this == &that)
            return (*this); /* in case "a = a" causes unexpected behavior */

        /* because the size of 2D array is fixed, we ignore the copy operation if the
        size of these arrays are not equal. */
        if (that.baseptr == NULL || this->nX != that.nX || this->nY != that.nY) {
            return;
        }
        for (int i = 0; i < this->nX * this->nY; i++) {
            /* may invoke overridden operator "=" for a class instance */
            this->baseptr[i] = that.baseptr[i];
        }

        return (*this);
    }

    T& at(int x, int y) {
        /* the user need to check if x and y is not out of bound */
        return baseptr[y*nX + x];
    }

    /* paste the content of this 2D array to target array, the upper-left position 
    is indicated by (x,y). */
    void paste_to(FixedArray2D& target, int x, int y) {
        for (int iy = 0; iy < sizeY(); iy++) {
            for (int ix = 0; ix < sizeX(); ix++) {
                int xT = ix + x;
                int yT = iy + y;
                if (xT < 0 || xT >= target.sizeX() || yT < 0 || yT >= target.sizeY())
                    continue;
                target.at(xT, yT) = this->at(ix, iy);
            }
        }
    }

    int sizeX() { return this->nX; }
    int sizeY() { return this->nY; }
    int size() { return this->nX * this->nY; }

    T* data() { return baseptr; }
    
    bool create(int nX, int nY) {
        if (nX <= 0 || nY <= 0) 
            return false;

        this->clear();

        this->baseptr = (T*)malloc(sizeof(T) * nX * nY);
        if (this->baseptr == NULL)
            return false;
        
        this->nX = nX;
        this->nY = nY;

        /* initialize all slots */
        for (int i = 0; i < nX * nY; i++) {
            new (&(this->baseptr[i])) T();
        }
        return true;
    }

protected:
    void clear() {
        for (int i = 0; i < this->size(); i++) {
            this->baseptr[i].~T();
        }
        /* then, free memory as usual */
        if (baseptr) free(baseptr);
        baseptr = NULL;
        nX = nY = 0;
    }

protected:
    T* baseptr; /* base pointer to the start of the memory storage */
    int nX, nY; /* number of columns & rows */



};

/* * * * * * * * * * * * * * * * * * * * * * * * */
/* generic stack implementation which is almost  */
/* identical to "Array" but has some differences */
/* * * * * * * * * * * * * * * * * * * * * * * * */
template <typename T>
class Stack {

    /*

    IMPORTANT NOTE:

    If "T" is a class rather than a pure data structure, then T must
    implement the following functions for correctly initializing/free
    memory spaces. I strongly recommend you to implement them manually
    and don't use the their default versions which are generated by the
    compilers.

    1) a DEFAULT constructor:         T::T().
    2) a (virtual) destructor:        (virtual) T::~T().
    3) a copy constructor:            T::T(const T&)().
    4) an overloaded operator "=":    T& operator=(const T&).

    */

public:

    Stack() { baseptr = NULL; Ne = 0; Me = 0; }
    Stack(const Stack& that) {
        this->Ne = that.Ne;
        this->Me = that.Me;
        /* initialize baseptr */
        if (that.Me == 0) { /* copy an empty Stack */
            this->baseptr = NULL;
        }
        else {
            this->baseptr = (T*)malloc(sizeof(T) * this->Me);
            /* only initialize used slots */
            for (int i = 0; i < this->Ne; i++) {
                new (&(this->baseptr[i])) T();
                /* may invoke overridden operator "=" if Stack element is */
                /* a class instance */
                this->baseptr[i] = that.baseptr[i];
            }
        }
    }
    virtual ~Stack() { this->clear(); }

    Stack& operator=(const Stack& that) {
        if (this == &that)
            return (*this); /* in case "a = a" will cause unexpected behavior */

        clear();

        this->Ne = that.Ne;
        this->Me = that.Me;
        /* initialize baseptr */
        if (that.Me == 0) { /* copy an empty Stack */
            this->baseptr = NULL;
        }
        else {
            this->baseptr = (T*)malloc(sizeof(T) * this->Me);
            /* only initialize used slots */
            for (int i = 0; i < this->Ne; i++) {
                new (&(this->baseptr[i])) T();
                /* may invoke overridden operator "=" if Stack element is */
                /* a class instance */
                this->baseptr[i] = that.baseptr[i];
            }
        }

        return (*this);
    }

public:

    bool push(T& elem) {
        if (Ne == Me) /* stack is full, expand it */
            expandStorage();
        /* note: the current stack top may stored some elements
           before, which also may contains some trash data (such as
           some wild pointers, although the destructor has been
           called, the pointer value may not be set to NULL). If we
           directly assign "elem" to stack top these trash data will
           cause safety issues. So here we need to call constructor
           to initialize memory before assignment.
        */
        new (&(this->baseptr[Ne])) T(); /* init stack top and prepare
                                           for assignment later */
        baseptr[Ne] = elem;
        Ne++;
        return true; /* normally push() will always success */
    }
    bool pop(T& elem) {
        if (Ne == 0) {
            /* already empty, cannot pop any element */
            return false;
        }
        else {
            Ne--;
            elem = baseptr[Ne]; /* copy element from stack */
            baseptr[Ne].~T(); /* destroy element in stack */
            return true;
        }
    }
    void clear() {
        /* if each element in the Stack is a class instance,     */
        /* we need to manually call destructor for each instance */
        /* in order to release memory propoerly (especially when */
        /* class instance member contains pointer(s)             */
        for (int i = 0; i < this->Ne; i++) {
            this->baseptr[i].~T();
        }
        /* then, free memory as usual */
        if (baseptr) free(baseptr);
        baseptr = NULL;
        Ne = Me = 0;
    }
    int size() { return this->Ne; }
    bool isEmpty() { return (this->Ne == 0); }

protected:
    T* baseptr; /* data pointer */
    int Ne, Me; /* number of elements and max number of elements allowed */
protected:
    void expandStorage() {
        if (Me == 0) { /* Stack is not initialized */
            Me = 16;
            baseptr = (T*)malloc(sizeof(T) * Me);
        }
        else {
            int maxIncreaseAllowed = 64 * 1024 * 1024; /* maximum 64MB per increase */
            int maxElementsIncrease = maxIncreaseAllowed / sizeof(T);
            int newMe = int(double(Me) * 1.1);
            if (maxElementsIncrease < 16) {
                maxElementsIncrease = 16;
            }
            if (newMe - Me > maxElementsIncrease) {
                newMe = Me + maxElementsIncrease; /* limit increase amount */
            }
            baseptr = (T*)realloc(baseptr, sizeof(T) * newMe); /* expand size */
            Me = newMe;
        }
    }
};

/* * * * * * * * * * * * * * * * * * * */
/* generic looped queue implementation */
/* * * * * * * * * * * * * * * * * * * */
template <typename T>
class Queue {

    /*

    IMPORTANT NOTE:

    If "T" is a class rather than a pure data structure, then T must
    implement the following functions for correctly initializing/free
    memory spaces. I strongly recommend you to implement them manually
    and don't use the their default versions which are generated by the
    compilers.

    1) a DEFAULT constructor:         T::T().
    2) a (virtual) destructor:        (virtual) T::~T().
    3) a copy constructor:            T::T(const T&)().
    4) an overloaded operator "=":    T& operator=(const T&).

    */

    /* looped queue 
    
    index:   0   1   2   3   4   ...   Me-1
     used:   n   n   y   y   n   ...   n
    Qstart = 2
      Qend = 4
      
    */

public:
    Queue() {
        baseptr = NULL;
        Me = 0;
        Qstart = -1; Qend = -1;
    }
    virtual ~Queue() {
        purge();
    }
    Queue(const Queue& that) {
        Me = that.Me;
        Qstart = that.Qstart; 
        Qend = that.Qend;
        baseptr = (T*)malloc(sizeof(T) * Me);
        for (int i = Qstart; i != Qend; i = nextIndex(i)) {
            new (this->baseptr + i) T();
            baseptr[i] = that.baseptr[i];
        }
    }

    Queue& operator=(const Queue& that) {
        if (this == &that)
            return (*this);
        purge();

        Me = that.Me;
        Qstart = that.Qstart;
        Qend = that.Qend;
        baseptr = (T*)malloc(sizeof(T) * Me);
        for (int i = Qstart; i != Qend; i = nextIndex(i)) {
            new (this->baseptr + i) T();
            baseptr[i] = that.baseptr[i];
        }

        return (*this);
    }

public:
    /* create a queue with n slots */
    bool create(int maxSize) {
        if (maxSize <= 0) return false;
        if (baseptr)
            purge();
        Me = maxSize + 1;
        baseptr = (T*)malloc(sizeof(T)*Me); /* reserve one slot unused */
        if (baseptr == NULL)
            return false;
        Qstart = 0;
        Qend = 0;
        return true;
    }
    /* put an element of type T into queue, return false if queue is full */
    bool put(T& elem) {
        if (nextIndex(Qend) == Qstart || baseptr == NULL) {
            return false; /* queue is full or not initialized */
        }
        new (this->baseptr + Qend) T();
        baseptr[Qend] = elem;
        Qend = nextIndex(Qend);
        return true;
    }
    /* get an element of type T from queue, return false if queue is empty */
    bool get(T& elem) {
        if (Qstart == Qend || baseptr == NULL) {
            return false; /* queue is empty */
        }
        elem = baseptr[Qstart];
        baseptr[Qstart].~T();
        Qstart = nextIndex(Qstart);
        return true;
    }
    /* check if queue is full/empty */
    bool isFull() { return sizeUsed() == sizeMax(); }
    bool isEmpty() { return sizeUsed() == 0; }
    /* clear the entire queue (but keep all slots remained) */
    void clear() {
        /* delete current elements in queue */
        for (int i = Qstart; i != Qend; i = nextIndex(i)) {
            baseptr[i].~T();
        }
        /* reset all counters */
        Qstart = Qend = 0;
    }
    /* get the number of elements currently stored in queue */
    int sizeUsed() { 
        if (Qend >= Qstart)
            return Qend - Qstart;
        else {
            return Me - Qstart + Qend;
        }
    }
    /* get the maximum number of elements this queue can store */
    int sizeMax() { return Me - 1; }

protected:
    /* delete the queue (only for internal use, completely removes the 
       whole queue and free allocated memory) */
    void purge() {
        /* delete current elements in queue */
        for (int i = Qstart; i != Qend; i = nextIndex(i)) {
            baseptr[i].~T();
        }
        if (baseptr) {
            free(baseptr);
            baseptr = NULL;
        }
        Me = 0;
        Qstart = -1; Qend = -1;
    }
    int nextIndex(int currentIndex) {
        if (currentIndex < 0 || currentIndex >= Me) return -1;
        else if (currentIndex == Me - 1) return 0;
        else return currentIndex + 1;
    }

protected:
    T* baseptr;
    int Me; /* 1 + maximum number of elements */
    int Qstart, Qend;

};

/* * * * * * * * * * * * * * * * * * * * * * * * * */
/* a simple bitstream class, defining a bitstream  */
/* buffer for writing with length less than 256MB  */
/* * * * * * * * * * * * * * * * * * * * * * * * * */
class Bitstream {
public:
    Bitstream() { 
        next_bit_write = 0;
        BYTE elem = 0x00;
        bitstream.append(elem);
        next_bit_read = 0;
    }
    /* append one bit to the bitstream buffer, any value larger than 1 is considered as bit "1" */
    void appendBit(BYTE bit) {
        /* write bit to buffer */
        if (bit > 0x01) bit = 0x01;
        BYTE last_byte = bitstream.last();
        int offset = next_bit_write % 8;
        last_byte |= ((bit & 0x01) << (7 - offset));
        bitstream.last() = last_byte;
        next_bit_write++;
        if (next_bit_write % 8 == 0) {
            /* append a byte to the buffer */
            BYTE elem = 0x00;
            bitstream.append(elem);
        }
    }
    /* append a small bitstream (<32 bits) to current bitstream */
    /* for example, if bitstream == "0000 0000 0000 0000 0010 1000 0100 1001" */
    /*                                     last 15 bits:  ^^^ ^^^^ ^^^^ ^^^^  */
    /* and bits == 15, the bitstream "010 1000 0100 1001" will append to current bitstream */
    void appendBits(unsigned int bitstream, int bits) {
        if (bits >= 32 || bits <= 0) return;
        while (bits > 0) {
            BYTE bit = (bitstream & (0x00000001U << (bits - 1))) ? 0x01 : 0x00;
            appendBit(bit);
            bits--;
        }
    }
    /* append a (possibly large) bitstream to current bitstream */
    void appendBitstream(Bitstream& bitstream, int bits) {
        for (int i = 0; i < bits; i++) {
            appendBit(bitstream[i]);
        }
    }
    /* align to the start of the next byte with specified bit. */
    /* If bit == 1, byte alignment is achieved by padding incomplete */
    /* byte with 1-bits, otherwise incomplete byte is padded with 0-bits. */
    void alignWrite(BYTE bit = 0) {
        if (bit > 0)
            bit = 1;
        while (next_bit_write % 8 != 0) {
            appendBit(bit);
        }
    }
    /* returns the corresponding bit at certain location */
    /* returns 0x00 if bit is 0, 0x01 if bit is 1, 0xFF if out of range */
    BYTE at(int index) {
        int ibyte = index / 8;
        int ibit = index % 8;
        if (ibyte < 0 || ibyte >= this->bitstream.size())
            return 0xFF; /* out of range */
        else {
            BYTE b = bitstream[ibyte];
            return (b & (1 << (7 - ibit))) > 0 ? 0x01 : 0x00;
        }
    }
    /* set bit, return false if out of range */
    bool setBit(int index, BYTE bit) {
        if (index < 0 || index >= size())
            return false;
        int ibyte = index / 8;
        int ibit = index % 8;
        BYTE byte = bitstream[ibyte];
        if (bit > 0)
            byte |= BYTE(1 << (7 - ibit));
        else
            byte &= ~BYTE(1 << (7 - ibit));
        bitstream[ibyte] = byte;
        return true;
    }
    /* operator[] */
    BYTE operator[](int index) {
        return at(index);
    }
    /* check if current bitstream is byte aligned */
    bool isAligned() {
        return next_bit_write % 8 == 0;
    }
    /* clear all bits */
    void clear() {
        bitstream.clear();
        next_bit_write = 0;
        /* append a 0x00 to prepare for next use */
        BYTE elem = 0x00;
        bitstream.append(elem); 
    }
    /* how many bits there are in the bitstream */
    int size() {
        return next_bit_write;
    }
    /* convert bitstreams to decimal values then compare */
    /* compare criterion: length first, value last. */
    /* for example: 00001 > 00000 > 1111 > 1110 > 011 > 1 > 0 */
    bool operator>(Bitstream& that) {
        if (this->size() > that.size())
            return true;
        else if (this->size() < that.size())
            return false;
        else {
            for (int i = 0; i < this->size(); i++) {
                if (this->at(i) > that.at(i))
                    return true;
                else if (this->at(i) < that.at(i))
                    return false;
            }
            return false;
        }
    }
    bool operator==(Bitstream& that) {
        if (this->size() != that.size())
            return false;
        for (int i = 0; i < this->size(); i++) {
            if (this->at(i) != that.at(i))
                return false;
        }
        return true;
    }
    bool operator<(Bitstream& that) {
        bool gt = this->operator>(that);
        bool eq = this->operator==(that);
        return (!gt) && (!eq);
    }
    /* convert bitstream to decimal value then add 1 (length is the same) */
    /* return false if the result overflows */
    bool inc() {
        int carry = 1;
        for (int bit = size() - 1; bit >= 0; bit--) {
            if (carry) {
                if (at(bit) == 0) {
                    setBit(bit, 1);
                    carry = 0;
                }
                else {
                    setBit(bit, 0);
                    carry = 1;
                }
            }
            else
                break;
        }
        if (carry) return false;
        return true;
    }
    /* obtain raw bitstream data (packed to bytes) */
    /* pad: pad the remaining bits to "0/1" if current bitstream is not byte aligned. */
    Array<BYTE> pack(BYTE pad_bit = 0) {
        Array<BYTE> pb;
        for (int i = 0; i < bitstream.size(); i++) {
            if (i != bitstream.size() - 1)
                pb.append(bitstream[i]);
            else { /* carefully determine the last byte */
                if (isAligned()) /* if bitstream is already aligned, it means the last byte does not */
                                 /* contain any valid bit, just ignore it */
                    break;
                else { /* the bitstream is not aligned, it means there are still some valid bits in */
                       /* this bitstream, we simply append them to the packed bitstream and pad with */
                       /* bit "1/0". */
                    int offset = next_bit_write % 8;
                    BYTE mask = ~((1 << (8 - offset)) - 1); /* mask="11111000" if 5 bits valid */
                    BYTE b = bitstream[bitstream.size() - 1]; /* extract last byte */
                    BYTE b_pad = (pad_bit == 0) ? (b & mask) : (b | (~mask));
                    pb.append(b_pad);
                    break;
                }
            }
        }
        return pb;
    }
    /* load an entire bitstream */
    void load(Array<BYTE>& packedBitstream) {
        for (int i = 0; i < packedBitstream.size(); i++) {
            BYTE packed = packedBitstream[i];
            appendBits(packed, 8);
        }
    }
    /* directly read single bit from bitstream, return 0xFF if no bit left */
    BYTE readBit() {
        if (next_bit_read >= next_bit_write)
            return 0xFF; /* no more bit left */
        BYTE bit = at(next_bit_read);
        next_bit_read++;
        return bit;
    }
    /* directly read many bits from bitstream (<=32), return 0xFFFFFFFF if no bit */
    /* left or length actual read is shorter than requested */
    unsigned int readBits(int length) {
        unsigned int bits = 0;
        for (int i = 0; i < length; i++) {
            BYTE bit = readBit();
            if (bit == 0xFF) return 0xFFFFFFFF;
            else bits = (bits << 1) | bit;
        }
        return bits;
    }
    bool alignRead() {
        if (next_bit_read >= next_bit_write) 
            return false;
        while (next_bit_read % 8 != 0)
            next_bit_read++;
    }

    /* for debug: print the whole bitstream */
    void _print() {
        for (int i = 0; i < size(); i++) {
            if (i != 0 && i % 8 == 0)
                printf(" ");
            printf("%s", at(i) > 0 ? "1" : "0");
        }
    }

protected:
    Array<BYTE> bitstream; /* packed bitstream */
    int next_bit_write; /* next bit index need to be written to */
    int next_bit_read;  /* next bit index need to be read from */
};

/* simple linked list (not tested yet) */
template <typename T>
class LinkedList {
public:

    LinkedList() { index = 0; }
    virtual ~LinkedList() {}

    /* add an element to linked list */
    void link(T* obj) {
        ptrlist.append(obj);
    }
    /* clear linked list */
    void clear() {
        ptrlist.clear();
    }
    /* retrieve the first element in the linked list */
    T* start() {
        index = 0;
        if (ptrlist.size() == 0) return NULL;
        else return ptrlist[index];
    }
    /* retrieve the next element in the linked list */
    T* next() {
        index++;
        if (index >= ptrlist.size()) {
            index = ptrlist.size();
            return NULL;
        }
        else
            return ptrlist[index];
    }
    /* check if we reach the tail of the linked list */
    bool isEnd() {
        if (index >= ptrlist.size() - 1) return true;
        else return false;
    }

protected:
    Array<T*> ptrlist;
    int index;
};

struct INT2 {
    union {
        int e[2];
        struct {
            int x, y;
        };
    };
    INT2() { e[X] = 0; e[Y] = 0; }
    INT2(int x, int y) { e[X] = x; e[Y] = y; }
};

struct INT3 {
    union {
        int e[3];
        struct {
            int x, y, z;
        };
    };
    INT3() { e[X] = 0; e[Y] = 0; e[Z] = 0; }
    INT3(int x, int y, int z) { e[X] = x; e[Y] = y; e[Z] = z; }
};

/* * * * * * * * * * * * * * * * */
/* basic file/string operations  */
/* * * * * * * * * * * * * * * * */
/* check if a certain character is in a string */
bool chInStr(char ch, const char* s);
/* get a single word from file/string, each word */
/* is separated by every character in wordDelim  */
bool getWord(FILE* fp, char* buf, int bufLen, const char* wordDelim = " #\n\r\t/", const char commentChar = '#');
bool getWord(char* src, char* buf, int bufLen, const char* wordDelim = " #\n\r\t/", const char commentChar = '#');
/* load basic data types from a text file */
bool getReal(FILE* fp, REAL* v); /* load a floating point number from file stream */
bool getInt(FILE* fp, int* v);   /* load an integer from file stream */
bool getVec3(FILE* fp, VEC3* v); /* load three floating point numbers from file stream */
bool getInt3(FILE* fp, INT3* v); /* load three integers from file stream */
/* load all characters from a text file */
bool loadTextFile(char* file, char* buf, int bufLen);
/* helper functions */
void printVec3(const char* prefix, VEC3 v);
void printMat3x3(const char* prefix, MAT3x3 m);
void printQuaternion(const char* prefix, QUATERNION q);

